<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvrio Content Curator</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: #f4f7f9; color: #333; margin: 0; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h1 { color: #2c3e50; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; }
        .controls { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .btn { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: background-color 0.2s; }
        .btn-approve { background-color: #27ae60; color: white; }
        .btn-approve:hover { background-color: #229954; }
        .btn-reject { background-color: #c0392b; color: white; }
        .btn-reject:hover { background-color: #a93226; }
        .btn-refresh { background-color: #3498db; color: white; margin-left: auto; }
        .btn-refresh:hover { background-color: #2980b9; }
        .btn-clear { background-color: #95a5a6; color: white; }
        .btn-clear:hover { background-color: #7f8c8d; }
        .btn:disabled { background-color: #95a5a6; cursor: not-allowed; }
        .filters { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #e0e0e0; }
        .filter-row { display: flex; gap: 15px; align-items: center; flex-wrap: wrap; }
        .filter-row label { font-weight: bold; color: #2c3e50; white-space: nowrap; }
        .filter-row select { padding: 8px; border: 1px solid #ddd; border-radius: 4px; background: white; }
        .content-item.hidden { display: none; }
        .preview-section { background-color: #f0f8ff; padding: 20px; border-radius: 8px; margin-bottom: 25px; border: 2px solid #3498db; }
        .preview-section h2 { margin-top: 0; color: #2c3e50; }
        .preview-tabs { display: flex; gap: 10px; margin-bottom: 15px; }
        .preview-tab { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; background-color: #ecf0f1; color: #2c3e50; font-weight: bold; transition: all 0.3s; }
        .preview-tab.active { background-color: #3498db; color: white; }
        .preview-tab:hover { background-color: #2980b9; color: white; }
        .preview-content { display: none; }
        .preview-content.active { display: block; }
        .preview-item { background-color: white; padding: 12px; margin-bottom: 8px; border-radius: 5px; border-left: 4px solid #3498db; }
        .preview-item h4 { margin: 0 0 5px 0; color: #2c3e50; }
        .preview-item .preview-meta { font-size: 0.85em; color: #666; }
        .preview-item a { color: #3498db; text-decoration: none; }
        .preview-item a:hover { text-decoration: underline; }
        #content-list { list-style-type: none; padding: 0; }
        .content-item { border: 1px solid #ddd; padding: 15px; margin-bottom: 10px; border-radius: 5px; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; transition: opacity 0.3s; }
        .content-item.processing { opacity: 0.5; pointer-events: none; }
        .content-details { flex-grow: 1; min-width: 300px; }
        .content-details h3 { margin: 0 0 5px 0; font-size: 1.1em; }
        .content-details a { color: #3498db; text-decoration: none; }
        .content-details a:hover { text-decoration: underline; }
        .content-meta { font-size: 0.9em; color: #777; }
        .item-actions .btn { font-size: 0.9em; padding: 5px 10px; }
        #status-message { margin-top: 15px; padding: 10px; border-radius: 5px; text-align: center; display: none; }
        .status-success { background-color: #eafaf1; color: #1e8449; }
        .status-error { background-color: #fdedec; color: #cb4335; }
        .visibility-indicator { font-size: 0.8em; padding: 4px 8px; border-radius: 12px; font-weight: bold; display: inline-block; margin-top: 5px; }
        .will-appear-latest { background-color: #e3f2fd; color: #1565c0; }
        .will-appear-picks { background-color: #fff3e0; color: #ef6c00; }
        .published-date { color: #666; font-size: 0.85em; margin-top: 3px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Content Curation</h1>
        
        <!-- Preview Section -->
        <div class="preview-section">
            <h2>üì∞ Website Preview - What Goes Live Next</h2>
            <div class="preview-tabs">
                <button id="preview-latest-tab" class="preview-tab active">Latest Intelligence (5 items)</button>
                <button id="preview-picks-tab" class="preview-tab">Canvrio's Picks (5 items)</button>
            </div>
            <div id="preview-latest-content" class="preview-content active"></div>
            <div id="preview-picks-content" class="preview-content"></div>
        </div>
        
        <!-- Content Mode Tabs -->
        <div class="content-tabs" style="display: flex; margin: 20px 0 10px 0; border-bottom: 2px solid #e0e0e0;">
            <button id="pending-tab" class="content-tab active" style="background: none; border: none; padding: 12px 20px; cursor: pointer; font-weight: bold; color: #3498db; border-bottom: 3px solid #3498db;">Pending Content</button>
            <button id="approved-tab" class="content-tab" style="background: none; border: none; padding: 12px 20px; cursor: pointer; font-weight: bold; color: #666; border-bottom: 3px solid transparent;">Approved Content</button>
        </div>
        
        <!-- Pending Controls -->
        <div id="pending-controls" class="controls">
            <label style="display: flex; align-items: center; gap: 8px; font-weight: bold; color: #2c3e50;">
                <input type="checkbox" id="select-all-pending" style="transform: scale(1.2);">
                Select All
            </label>
            <button id="bulk-approve-btn" class="btn btn-approve">Approve Selected</button>
            <button id="bulk-reject-btn" class="btn btn-reject">Reject Selected</button>
            <button id="reset-priorities-btn" class="btn btn-clear">Reset Priorities</button>
            <button id="refresh-btn" class="btn btn-refresh">Fetch New Content</button>
        </div>
        
        <!-- Approved Controls -->
        <div id="approved-controls" class="controls" style="display: none;">
            <label style="display: flex; align-items: center; gap: 8px; font-weight: bold; color: #2c3e50;">
                <input type="checkbox" id="select-all-approved" style="transform: scale(1.2);">
                Select All
            </label>
            <button id="bulk-reuse-btn" class="btn btn-approve" style="background-color: #f39c12;">‚Ü©Ô∏è Bulk Return to Pending</button>
        </div>
        
        <div class="filters">
            <div class="filter-row">
                <label>Filter by Source:</label>
                <select id="source-filter">
                    <option value="all">All Sources</option>
                    <option value="reddit">Reddit (All Subreddits)</option>
                    <option value="r/canadients">r/canadients</option>
                    <option value="r/TheOCS">r/TheOCS</option>
                    <option value="r/CanadianCannabisLPs">r/CanadianCannabisLPs</option>
                    <option value="StratCann">StratCann</option>
                    <option value="MJBizDaily">MJBizDaily</option>
                    <option value="New Cannabis Ventures">New Cannabis Ventures</option>
                    <option value="Cannabis Business Times">Cannabis Business Times</option>
                    <option value="Health Canada">Health Canada</option>
                </select>
                
                <label>Filter by Section:</label>
                <select id="section-filter">
                    <option value="all">All Sections</option>
                    <option value="latest">Will Appear in Latest Intelligence (< 48h)</option>
                    <option value="picks">Will Appear in Canvrio's Picks (> 48h)</option>
                </select>
                
                <label>Sort by:</label>
                <select id="sort-filter">
                    <option value="newest">Newest First</option>
                    <option value="oldest">Oldest First</option>
                    <option value="source">By Source</option>
                </select>
                
                <button id="clear-filters" class="btn btn-clear">Clear Filters</button>
            </div>
        </div>
        <ul id="content-list"></ul>
        <div id="status-message"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const contentList = document.getElementById('content-list');
            const bulkApproveBtn = document.getElementById('bulk-approve-btn');
            const bulkRejectBtn = document.getElementById('bulk-reject-btn');
            const resetPrioritiesBtn = document.getElementById('reset-priorities-btn');
            const refreshBtn = document.getElementById('refresh-btn');
            const statusMessage = document.getElementById('status-message');
            
            // Filter controls
            const sourceFilter = document.getElementById('source-filter');
            const sectionFilter = document.getElementById('section-filter');
            const sortFilter = document.getElementById('sort-filter');
            const clearFiltersBtn = document.getElementById('clear-filters');
            
            // Preview controls
            const previewLatestTab = document.getElementById('preview-latest-tab');
            const previewPicksTab = document.getElementById('preview-picks-tab');
            const previewLatestContent = document.getElementById('preview-latest-content');
            const previewPicksContent = document.getElementById('preview-picks-content');
            
            // Content mode tabs
            const pendingTab = document.getElementById('pending-tab');
            const approvedTab = document.getElementById('approved-tab');
            const pendingControls = document.getElementById('pending-controls');
            const approvedControls = document.getElementById('approved-controls');
            const bulkReuseBtn = document.getElementById('bulk-reuse-btn');
            
            let allContent = [];
            let currentMode = 'pending';

            const showStatus = (message, isError = false) => {
                statusMessage.textContent = message;
                statusMessage.className = isError ? 'status-error' : 'status-success';
                statusMessage.style.display = 'block';
                setTimeout(() => { statusMessage.style.display = 'none'; }, 4000);
            };

            const determineVisibility = (createdAt) => {
                const now = new Date();
                const created = new Date(createdAt);
                const hoursDiff = (now - created) / (1000 * 60 * 60);
                
                // If added to system within 7 days, will appear in "Latest Intelligence" 
                // Otherwise, will appear in "Canvrio's Picks" when approved
                if (hoursDiff <= 168) { // 7 days = 168 hours
                    return {
                        section: 'Latest Intelligence',
                        className: 'will-appear-latest',
                        icon: 'üì∞'
                    };
                } else {
                    return {
                        section: "Canvrio's Picks",
                        className: 'will-appear-picks', 
                        icon: '‚ú®'
                    };
                }
            };

            const formatPublishedDate = (dateString) => {
                const date = new Date(dateString);
                const now = new Date();
                const diffHours = (now - date) / (1000 * 60 * 60);
                
                if (diffHours < 1) {
                    return `${Math.floor(diffHours * 60)}m ago`;
                } else if (diffHours < 24) {
                    return `${Math.floor(diffHours)}h ago`;
                } else {
                    return `${Math.floor(diffHours / 24)}d ago`;
                }
            };

            const fetchContent = async () => {
                try {
                    const endpoint = currentMode === 'pending' ? '/api/content/pending' : '/api/content/approved';
                    const response = await fetch(endpoint);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const data = await response.json();

                    contentList.innerHTML = ''; // Clear existing list
                    if (data.content.length === 0) {
                        const message = currentMode === 'pending' ? 
                            'No pending content to review. Try fetching new content.' :
                            'No approved content found.';
                        contentList.innerHTML = `<li><p>${message}</p></li>`;
                        return;
                    }

                    allContent = data.content; // Store all content for filtering
                    renderContent(allContent);
                } catch (error) {
                    console.error(`Failed to fetch ${currentMode} content:`, error);
                    showStatus('Failed to load content. Please refresh the page.', true);
                }
            };

            const getBannerDestination = (publishedDate) => {
                const now = new Date();
                const published = new Date(publishedDate);
                const hoursAgo = Math.floor((now - published) / (1000 * 60 * 60));
                
                if (hoursAgo <= 48) {
                    if (hoursAgo < 1) {
                        return "üì∞ Will go to Latest Intelligence (published < 1 hour ago)";
                    } else if (hoursAgo === 1) {
                        return "üì∞ Will go to Latest Intelligence (published 1 hour ago)";
                    } else {
                        return `üì∞ Will go to Latest Intelligence (published ${hoursAgo} hours ago)`;
                    }
                } else {
                    const daysAgo = Math.floor(hoursAgo / 24);
                    if (daysAgo === 1) {
                        return "‚≠ê Will go to Canvrio's Picks (published 1 day ago)";
                    } else {
                        return `‚≠ê Will go to Canvrio's Picks (published ${daysAgo} days ago)`;
                    }
                }
            };

            const renderContent = (content) => {
                contentList.innerHTML = ''; // Clear existing list
                
                if (content.length === 0) {
                    const sectionValue = sectionFilter.value;
                    let message = 'No content matches the current filters.';
                    
                    if (sectionValue === 'picks') {
                        message = 'No content added to system more than 7 days ago found. Most content becomes available for "Canvrio\'s Picks" section after being in system for more than 7 days. Try the "Latest Intelligence" filter or "All Sections" to see available content.';
                    } else if (sectionValue === 'latest') {
                        message = 'No recently added content (within 7 days) found. Try "All Sections" or refresh content to fetch newer items.';
                    }
                    
                    contentList.innerHTML = `<li><p style="background-color: #fff3cd; padding: 15px; border-radius: 5px; border-left: 4px solid #ffc107; color: #856404;">${message}</p></li>`;
                    return;
                }
                
                content.forEach(item => {
                    const visibility = determineVisibility(item.created_at);
                    const publishedTime = formatPublishedDate(item.published_date);
                    
                    const li = document.createElement('li');
                    li.className = 'content-item';
                    li.id = `item-${item.id}`;
                    li.innerHTML = `
                        <input type="checkbox" class="bulk-checkbox" data-id="${item.id}">
                        <div class="content-details">
                            <h3>${item.title}</h3>
                            <p class="content-meta">
                                <strong>Source:</strong> ${item.source} | <strong>Category:</strong> ${item.category || 'General'}
                            </p>
                            <div class="published-date">Published: ${publishedTime}</div>
                            <div class="visibility-indicator ${visibility.className}">
                                ${visibility.icon} Will appear in: ${visibility.section}
                            </div>
                            <a href="${item.url}" target="_blank" rel="noopener noreferrer">View Original</a>
                        </div>
                        <div class="item-actions">
                            <select class="priority-select" data-id="${item.id}" style="margin-right: 8px; padding: 5px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="1" ${(item.priority || 3) === 1 ? 'selected' : ''}>üö® Breaking</option>
                                <option value="2" ${(item.priority || 3) === 2 ? 'selected' : ''}>üî• High</option>
                                <option value="3" ${(item.priority || 3) === 3 ? 'selected' : ''}>üì∞ Normal</option>
                                <option value="4" ${(item.priority || 3) === 4 ? 'selected' : ''}>üìÑ Low</option>
                                <option value="5" ${(item.priority || 3) === 5 ? 'selected' : ''}>üìÅ Archive</option>
                            </select>
                            ${currentMode === 'pending' ? `
                                <button class="btn btn-approve single-action-btn" data-id="${item.id}" data-action="approve" data-published-date="${item.published_date}">Approve</button>
                                <button class="btn btn-reject single-action-btn" data-id="${item.id}" data-action="reject">Reject</button>
                            ` : `
                                <button class="btn btn-approve single-action-btn" data-id="${item.id}" data-action="unapprove" style="background-color: #f39c12;">‚Ü©Ô∏è Return to Pending</button>
                            `}
                        </div>
                    `;
                    contentList.appendChild(li);
                });
                
                // Set tooltips for approve buttons after elements are created
                document.querySelectorAll('.single-action-btn[data-action="approve"][data-published-date]').forEach(button => {
                    const publishedDate = button.getAttribute('data-published-date');
                    button.title = getBannerDestination(publishedDate);
                });
            };

            const filterAndSortContent = () => {
                let filtered = [...allContent];
                
                // Filter by source
                const sourceValue = sourceFilter.value;
                if (sourceValue !== 'all') {
                    filtered = filtered.filter(item => {
                        if (sourceValue === 'reddit') {
                            return item.source.toLowerCase().includes('reddit') || item.source.toLowerCase().includes('r/');
                        } else if (sourceValue.startsWith('r/')) {
                            return item.source.toLowerCase().includes(sourceValue.toLowerCase());
                        } else {
                            return item.source.toLowerCase().includes(sourceValue.toLowerCase());
                        }
                    });
                }
                
                // Filter by section (Latest Intelligence vs Canvrio's Picks)
                const sectionValue = sectionFilter.value;
                if (sectionValue !== 'all') {
                    filtered = filtered.filter(item => {
                        const now = new Date();
                        const created = new Date(item.created_at);
                        const hoursDiff = (now - created) / (1000 * 60 * 60);
                        
                        if (sectionValue === 'latest') return hoursDiff <= 168; // 7 days since added
                        if (sectionValue === 'picks') return hoursDiff > 168; // older than 7 days since added
                        return true;
                    });
                }
                
                // Sort content
                const sortValue = sortFilter.value;
                filtered.sort((a, b) => {
                    if (sortValue === 'newest') {
                        return new Date(b.published_date) - new Date(a.published_date);
                    } else if (sortValue === 'oldest') {
                        return new Date(a.published_date) - new Date(b.published_date);
                    } else if (sortValue === 'source') {
                        return a.source.localeCompare(b.source);
                    }
                    return 0;
                });
                
                renderContent(filtered);
            };

            const loadPreviewContent = async () => {
                try {
                    // Fetch both Latest Intelligence and Canvrio's Picks
                    const [latestResponse, picksResponse] = await Promise.all([
                        fetch('/api/content/latest?limit=5'),
                        fetch('/api/content/canvrio-picks?limit=5')
                    ]);
                    
                    const latestData = await latestResponse.json();
                    const picksData = await picksResponse.json();
                    
                    renderPreviewContent('latest', latestData.content || []);
                    renderPreviewContent('picks', picksData.content || []);
                    
                } catch (error) {
                    console.error('Failed to load preview content:', error);
                    previewLatestContent.innerHTML = '<p>Failed to load preview. Check console for details.</p>';
                    previewPicksContent.innerHTML = '<p>Failed to load preview. Check console for details.</p>';
                }
            };

            const renderPreviewContent = (type, content) => {
                const container = type === 'latest' ? previewLatestContent : previewPicksContent;
                
                if (content.length === 0) {
                    container.innerHTML = '<p>No approved content available yet. Approve some content to see it here!</p>';
                    return;
                }
                
                container.innerHTML = content.map((item, index) => `
                    <div class="preview-item">
                        <h4>#${index + 1} ${item.title}</h4>
                        <div class="preview-meta">
                            <strong>Source:</strong> ${item.source} | 
                            <strong>Published:</strong> ${formatPublishedDate(item.published_date)}
                            ${type === 'picks' ? ' | <strong>Approved:</strong> ' + formatPublishedDate(item.approval_timestamp) : ''}
                        </div>
                        <a href="${item.url}" target="_blank">View Original ‚Üí</a>
                    </div>
                `).join('');
            };

            const switchPreviewTab = (activeTab) => {
                // Remove active class from all tabs and content
                previewLatestTab.classList.remove('active');
                previewPicksTab.classList.remove('active');
                previewLatestContent.classList.remove('active');
                previewPicksContent.classList.remove('active');
                
                // Add active class to selected tab and content
                if (activeTab === 'latest') {
                    previewLatestTab.classList.add('active');
                    previewLatestContent.classList.add('active');
                } else {
                    previewPicksTab.classList.add('active');
                    previewPicksContent.classList.add('active');
                }
            };

            const switchContentMode = (mode) => {
                currentMode = mode;
                
                // Update tab appearance
                pendingTab.classList.remove('active');
                approvedTab.classList.remove('active');
                pendingTab.style.color = '#666';
                pendingTab.style.borderBottomColor = 'transparent';
                approvedTab.style.color = '#666';
                approvedTab.style.borderBottomColor = 'transparent';
                
                if (mode === 'pending') {
                    pendingTab.classList.add('active');
                    pendingTab.style.color = '#3498db';
                    pendingTab.style.borderBottomColor = '#3498db';
                    pendingControls.style.display = 'flex';
                    approvedControls.style.display = 'none';
                } else {
                    approvedTab.classList.add('active');
                    approvedTab.style.color = '#3498db';
                    approvedTab.style.borderBottomColor = '#3498db';
                    pendingControls.style.display = 'none';
                    approvedControls.style.display = 'flex';
                }
                
                // Clear select all checkboxes when switching modes
                document.getElementById('select-all-pending').checked = false;
                document.getElementById('select-all-approved').checked = false;
                
                // Fetch content for the new mode
                fetchContent();
            };

            const handleSingleAction = async (contentId, action) => {
                const itemElement = document.getElementById(`item-${contentId}`);
                itemElement.classList.add('processing');
                
                try {
                    const endpoint = action === 'unapprove' ? `/api/content/${contentId}/unapprove` : 
                                   action === 'reuse' ? `/api/content/${contentId}/reuse` : 
                                   `/api/content/${contentId}/${action}`;
                    const response = await fetch(endpoint, { method: 'POST' });
                    if (!response.ok) throw new Error(`Failed to ${action} content.`);
                    
                    itemElement.style.opacity = '0';
                    setTimeout(() => itemElement.remove(), 300); // Remove after fade out
                    
                    const actionText = action === 'approve' ? 'approved' : 
                                      action === 'unapprove' ? 'returned to pending' : 
                                      action === 'reuse' ? 'returned to pending' : 'rejected';
                    showStatus(`Content item #${contentId} ${actionText} successfully.`);
                    
                    // Refresh preview if content was approved or reused
                    if (action === 'approve' || action === 'reuse') {
                        loadPreviewContent();
                    }
                } catch (error) {
                    console.error(error);
                    showStatus(error.message, true);
                    itemElement.classList.remove('processing');
                }
            };

            const handleBulkAction = async (action) => {
                const selectedCheckboxes = document.querySelectorAll('.bulk-checkbox:checked');
                const content_ids = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));

                if (content_ids.length === 0) {
                    showStatus('Please select items to perform a bulk action.', true);
                    return;
                }

                try {
                    const response = await fetch(`/api/content/bulk/${action}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content_ids })
                    });
                    if (!response.ok) throw new Error(`Failed to bulk ${action}.`);

                    showStatus(`${content_ids.length} items have been ${action}d. Refreshing list.`);
                    setTimeout(fetchContent, 1000); // Refresh list after a short delay
                    
                    // Refresh preview if content was approved
                    if (action === 'approve') {
                        setTimeout(loadPreviewContent, 1200); // Slight delay to ensure backend updates
                    }
                } catch (error) {
                    console.error(error);
                    showStatus(error.message, true);
                }
            };

            const handleBulkReuse = async () => {
                const selectedCheckboxes = document.querySelectorAll('.bulk-checkbox:checked');
                const content_ids = Array.from(selectedCheckboxes).map(cb => parseInt(cb.dataset.id));

                if (content_ids.length === 0) {
                    showStatus('Please select items to return to pending.', true);
                    return;
                }

                try {
                    // Use individual unapprove calls since we know that endpoint works
                    const promises = content_ids.map(id => 
                        fetch(`/api/content/${id}/unapprove`, { method: 'POST' })
                    );
                    const responses = await Promise.all(promises);
                    
                    const successCount = responses.filter(r => r.ok).length;
                    const failedCount = content_ids.length - successCount;
                    
                    if (successCount > 0) {
                        showStatus(`${successCount} items returned to pending. Refreshing list.`);
                        setTimeout(fetchContent, 1000);
                        setTimeout(loadPreviewContent, 1200);
                    }
                    
                    if (failedCount > 0) {
                        showStatus(`${failedCount} items failed to return to pending.`, true);
                    }
                } catch (error) {
                    console.error(error);
                    showStatus('Return to pending failed.', true);
                }
            };

            const handleResetPriorities = async () => {
                if (!confirm('This will reset ALL content priorities to Normal (3). Are you sure?')) {
                    return;
                }

                resetPrioritiesBtn.disabled = true;
                resetPrioritiesBtn.textContent = 'Resetting...';
                showStatus('Resetting all priorities to Normal...');

                try {
                    const response = await fetch('/api/content/0/priority', { 
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ priority: 3 })
                    });
                    if (!response.ok) throw new Error('Failed to reset priorities.');
                    
                    showStatus('All priorities reset to Normal. Refreshing content.');
                    setTimeout(fetchContent, 1000);
                } catch (error) {
                    console.error(error);
                    showStatus('Failed to reset priorities.', true);
                } finally {
                    resetPrioritiesBtn.disabled = false;
                    resetPrioritiesBtn.textContent = 'Reset Priorities';
                }
            };
            
            const handleRefresh = async () => {
                refreshBtn.disabled = true;
                refreshBtn.textContent = 'Fetching...';
                showStatus('Content refresh initiated. This may take a moment.');

                try {
                    const response = await fetch('/api/content/refresh', { method: 'POST' });
                    if (!response.ok) throw new Error('Failed to start refresh process.');
                    
                    setTimeout(() => {
                        showStatus('Refresh complete. Loading new content.');
                        fetchContent();
                    }, 3000);

                } catch (error) {
                    console.error(error);
                    showStatus(error.message, true);
                } finally {
                    setTimeout(() => {
                        refreshBtn.disabled = false;
                        refreshBtn.textContent = 'Fetch New Content';
                    }, 3000);
                }
            };
            
            // Event Listeners
            contentList.addEventListener('click', (e) => {
                if (e.target.classList.contains('single-action-btn')) {
                    const id = e.target.dataset.id;
                    const action = e.target.dataset.action;
                    handleSingleAction(id, action);
                }
            });

            // Priority change handler
            contentList.addEventListener('change', (e) => {
                if (e.target.classList.contains('priority-select')) {
                    const contentId = e.target.dataset.id;
                    const priority = parseInt(e.target.value);
                    handlePriorityChange(contentId, priority);
                }
            });

            const handlePriorityChange = async (contentId, priority) => {
                try {
                    const response = await fetch(`/api/content/${contentId}/priority`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ priority: priority })
                    });
                    if (!response.ok) throw new Error('Failed to update priority.');
                    
                    const priorityNames = {1: 'Breaking', 2: 'High', 3: 'Normal', 4: 'Low', 5: 'Archive'};
                    showStatus(`Priority set to ${priorityNames[priority]} for content #${contentId}`);
                } catch (error) {
                    console.error(error);
                    showStatus(error.message, true);
                }
            };

            bulkApproveBtn.addEventListener('click', () => handleBulkAction('approve'));
            bulkRejectBtn.addEventListener('click', () => handleBulkAction('reject'));
            resetPrioritiesBtn.addEventListener('click', handleResetPriorities);
            refreshBtn.addEventListener('click', handleRefresh);
            bulkReuseBtn.addEventListener('click', handleBulkReuse);
            
            // Content mode tab event listeners
            pendingTab.addEventListener('click', () => switchContentMode('pending'));
            approvedTab.addEventListener('click', () => switchContentMode('approved'));
            
            // Select All functionality
            document.getElementById('select-all-pending').addEventListener('change', (e) => {
                const checkboxes = document.querySelectorAll('.bulk-checkbox');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            });
            
            document.getElementById('select-all-approved').addEventListener('change', (e) => {
                const checkboxes = document.querySelectorAll('.bulk-checkbox');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            });
            
            // Filter event listeners
            sourceFilter.addEventListener('change', filterAndSortContent);
            sectionFilter.addEventListener('change', filterAndSortContent);
            sortFilter.addEventListener('change', filterAndSortContent);
            clearFiltersBtn.addEventListener('click', () => {
                sourceFilter.value = 'all';
                sectionFilter.value = 'all';
                sortFilter.value = 'newest';
                filterAndSortContent();
            });
            
            // Preview tab event listeners
            previewLatestTab.addEventListener('click', () => switchPreviewTab('latest'));
            previewPicksTab.addEventListener('click', () => switchPreviewTab('picks'));
            
            // Initial Load
            fetchContent();
            loadPreviewContent();
        });
    </script>
</body>
</html>